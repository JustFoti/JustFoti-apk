'use client';

import { useState, useEffect, useRef } from 'react';
import Link from 'next/link';
import { motion, AnimatePresence } from 'framer-motion';
import styles from './ReverseEngineering.module.css';

const sections = [
  { id: 'overview', title: 'Overview', icon: 'üéØ' },
  { id: 'philosophy', title: 'Philosophy', icon: 'üí≠' },
  { id: 'dlhd', title: 'DLHD Live TV', icon: 'üì∫' },
  { id: '111movies', title: '111movies', icon: 'üé¨' },
  { id: 'flixer', title: 'Flixer (WASM)', icon: 'üîê' },
  { id: 'vidsrc', title: 'VidSrc', icon: 'üì°' },
  { id: 'videasy', title: 'Videasy', icon: 'üåç' },
  { id: 'animekai', title: 'AnimeKai', icon: 'üéå' },
  { id: 'megaup', title: 'MegaUp', icon: 'üîì' },
  { id: 'proxy-architecture', title: 'Proxy Architecture', icon: 'üîÑ' },
  { id: 'techniques', title: 'Techniques', icon: 'üõ†Ô∏è' },
  { id: 'tools', title: 'Tools', icon: 'üß∞' },
  { id: 'contribute', title: 'Contributing', icon: 'ü§ù' },
];

const providerStats = [
  { name: 'DLHD', status: 'working', type: 'Live TV', method: 'PoW + Timestamp Validation' },
  { name: '111movies', status: 'working', type: 'Movies/TV', method: 'AES-256-CBC + XOR' },
  { name: 'Flixer', status: 'working', type: 'Movies/TV', method: 'WASM Bundling' },
  { name: 'VidSrc', status: 'working', type: 'Movies/TV', method: 'Static Decoders' },
  { name: 'Videasy', status: 'working', type: 'Multi-Lang', method: 'External API' },
  { name: 'AnimeKai', status: 'working', type: 'Anime', method: 'Native Crypto (183 Tables)' },
  { name: 'MegaUp', status: 'working', type: 'CDN', method: 'UA-Based Stream Cipher' },
];

function CodeBlock({ title, code, id, copiedCode, onCopy }: { 
  title: string; 
  code: string; 
  id: string;
  copiedCode: string | null;
  onCopy: (code: string, id: string) => void;
}) {
  return (
    <div className={styles.codeBlock}>
      <div className={styles.codeHeader}>
        <span className={styles.codeTitle}>{title}</span>
        <button 
          onClick={() => onCopy(code, id)}
          className={`${styles.copyBtn} ${copiedCode === id ? styles.copied : ''}`}
        >
          {copiedCode === id ? '‚úì Copied' : 'Copy'}
        </button>
      </div>
      <pre className={styles.codeContent}>
        <code>{code}</code>
      </pre>
    </div>
  );
}

function FlowStep({ num, title, description }: { num: number; title: string; description: string }) {
  return (
    <motion.div 
      className={styles.flowStep}
      initial={{ opacity: 0, x: -20 }}
      whileInView={{ opacity: 1, x: 0 }}
      viewport={{ once: true }}
      transition={{ delay: num * 0.1 }}
    >
      <div className={styles.stepNum}>{num}</div>
      <div className={styles.stepContent}>
        <h4>{title}</h4>
        <p>{description}</p>
      </div>
    </motion.div>
  );
}

function ProviderCard({ name, type, method, delay }: { 
  name: string; 
  type: string; 
  method: string;
  delay: number;
}) {
  return (
    <motion.div 
      className={styles.providerCard}
      initial={{ opacity: 0, y: 20 }}
      whileInView={{ opacity: 1, y: 0 }}
      viewport={{ once: true }}
      transition={{ delay }}
      whileHover={{ scale: 1.02, y: -5 }}
    >
      <div className={styles.providerStatus}>
        <span className={styles.statusDot} />
        Working
      </div>
      <h3>{name}</h3>
      <div className={styles.providerMeta}>
        <span className={styles.providerType}>{type}</span>
        <span className={styles.providerMethod}>{method}</span>
      </div>
    </motion.div>
  );
}

export default function ReverseEngineeringPage() {
  const [activeSection, setActiveSection] = useState('overview');
  const [progress, setProgress] = useState(0);
  const [copiedCode, setCopiedCode] = useState<string | null>(null);
  const [mobileNavOpen, setMobileNavOpen] = useState(false);
  const contentRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const onScroll = () => {
      const scrollTop = window.scrollY;
      const docHeight = document.documentElement.scrollHeight - window.innerHeight;
      setProgress((scrollTop / docHeight) * 100);

      for (const section of sections) {
        const el = document.getElementById(section.id);
        if (el) {
          const rect = el.getBoundingClientRect();
          if (rect.top <= 150 && rect.bottom > 150) {
            setActiveSection(section.id);
            break;
          }
        }
      }
    };

    window.addEventListener('scroll', onScroll);
    return () => window.removeEventListener('scroll', onScroll);
  }, []);

  const copyCode = (code: string, id: string) => {
    navigator.clipboard.writeText(code);
    setCopiedCode(id);
    setTimeout(() => setCopiedCode(null), 2000);
  };

  const scrollToSection = (id: string) => {
    document.getElementById(id)?.scrollIntoView({ behavior: 'smooth' });
    setMobileNavOpen(false);
  };

  return (
    <div className={styles.page}>
      {/* Progress Bar */}
      <div className={styles.progressBar} style={{ width: `${progress}%` }} />
      
      {/* Animated Background */}
      <div className={styles.bgEffects}>
        <div className={styles.bgOrb1} />
        <div className={styles.bgOrb2} />
        <div className={styles.bgOrb3} />
        <div className={styles.bgGrid} />
      </div>

      {/* Hero Section */}
      <header className={styles.hero}>
        <motion.div 
          className={styles.heroContent}
          initial={{ opacity: 0, y: 30 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8 }}
        >
          <Link href="/about" className={styles.backLink}>
            <span>‚Üê</span> Back to About
          </Link>
          
          <motion.div 
            className={styles.badge}
            initial={{ opacity: 0, scale: 0.8 }}
            animate={{ opacity: 1, scale: 1 }}
            transition={{ delay: 0.2 }}
          >
            <span className={styles.badgeDot} />
            Technical Documentation ‚Ä¢ January 2026
          </motion.div>
          
          <h1 className={styles.heroTitle}>
            <span className={styles.titleGradient}>Reverse Engineering</span>
            <br />
            <span className={styles.titleSecondary}>Streaming Providers</span>
          </h1>
          
          <p className={styles.heroSubtitle}>
            A comprehensive guide to bypassing embed protections and extracting clean m3u8 streams 
            without ads, popups, or malware. Updated January 2026 with PoW authentication, WASM 
            cracking, and 183-table cipher analysis.
          </p>

          <motion.div 
            className={styles.warningBox}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.4 }}
          >
            <div className={styles.warningIcon}>‚ö†Ô∏è</div>
            <div className={styles.warningContent}>
              <strong>Educational Purpose Only</strong>
              <p>
                This documentation demonstrates how streaming site protections work. 
                Use this knowledge responsibly.
              </p>
            </div>
          </motion.div>

          {/* Quick Stats */}
          <motion.div 
            className={styles.quickStats}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.5 }}
          >
            <div className={styles.stat}>
              <span className={styles.statNum}>8</span>
              <span className={styles.statLabel}>Providers</span>
            </div>
            <div className={styles.stat}>
              <span className={styles.statNum}>100%</span>
              <span className={styles.statLabel}>Working</span>
            </div>
            <div className={styles.stat}>
              <span className={styles.statNum}>0</span>
              <span className={styles.statLabel}>Browser Automation</span>
            </div>
          </motion.div>
        </motion.div>
      </header>

      {/* Mobile Nav Toggle */}
      <button 
        className={styles.mobileNavToggle}
        onClick={() => setMobileNavOpen(!mobileNavOpen)}
      >
        <span className={styles.navIcon}>‚ò∞</span>
        <span>{sections.find(s => s.id === activeSection)?.title}</span>
        <span className={styles.navProgress}>{Math.round(progress)}%</span>
      </button>

      {/* Mobile Nav Overlay */}
      <AnimatePresence>
        {mobileNavOpen && (
          <motion.div 
            className={styles.mobileNavOverlay}
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={() => setMobileNavOpen(false)}
          >
            <motion.nav 
              className={styles.mobileNav}
              initial={{ x: '-100%' }}
              animate={{ x: 0 }}
              exit={{ x: '-100%' }}
              onClick={e => e.stopPropagation()}
            >
              <div className={styles.mobileNavHeader}>
                <span>Contents</span>
                <button onClick={() => setMobileNavOpen(false)}>‚úï</button>
              </div>
              {sections.map((s) => (
                <button
                  key={s.id}
                  className={`${styles.mobileNavItem} ${activeSection === s.id ? styles.active : ''}`}
                  onClick={() => scrollToSection(s.id)}
                >
                  <span className={styles.navItemIcon}>{s.icon}</span>
                  {s.title}
                </button>
              ))}
            </motion.nav>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Main Layout */}
      <div className={styles.layout}>
        {/* Desktop Sidebar */}
        <nav className={styles.sidebar}>
          <div className={styles.sidebarInner}>
            <div className={styles.sidebarHeader}>
              <span>Contents</span>
              <span className={styles.sidebarProgress}>{Math.round(progress)}%</span>
            </div>
            {sections.map((s, i) => (
              <button
                key={s.id}
                className={`${styles.navItem} ${activeSection === s.id ? styles.active : ''}`}
                onClick={() => scrollToSection(s.id)}
              >
                <span className={styles.navNum}>{String(i + 1).padStart(2, '0')}</span>
                <span className={styles.navItemIcon}>{s.icon}</span>
                <span className={styles.navItemTitle}>{s.title}</span>
              </button>
            ))}
          </div>
        </nav>

        {/* Content */}
        <main className={styles.content} ref={contentRef}>

          {/* Overview Section */}
          <section id="overview" className={styles.section}>
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
            >
              <h2 className={styles.sectionTitle}>
                <span className={styles.sectionIcon}>üéØ</span>
                Overview
              </h2>
              
              <p className={styles.lead}>
                Most &quot;free&quot; streaming sites wrap their content in layers of obfuscation, 
                aggressive advertising, and sometimes outright malware. But here&apos;s the thing: 
                the actual video streams are just standard HLS (m3u8) files.
              </p>
              
              <p>
                By reverse engineering these protections, we can extract the clean stream URLs and 
                play them in our own player‚Äîno ads, no popups, no cryptocurrency miners. As of 
                January 2026, we&apos;ve cracked 8 providers including PoW authentication, WASM 
                binaries, and 183-table substitution ciphers.
              </p>

              <div className={styles.providerGrid}>
                {providerStats.map((provider, i) => (
                  <ProviderCard key={provider.name} {...provider} delay={i * 0.1} />
                ))}
              </div>
            </motion.div>
          </section>

          {/* Philosophy Section */}
          <section id="philosophy" className={styles.section}>
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
            >
              <h2 className={styles.sectionTitle}>
                <span className={styles.sectionIcon}>üí≠</span>
                Philosophy
              </h2>
              
              <h3>Why We Do This</h3>
              <p>
                The streaming sites we reverse engineer are not legitimate businesses. They profit 
                from content they don&apos;t own by wrapping it in exploitative monetization. We&apos;re 
                not stealing from creators‚Äîwe&apos;re bypassing the middlemen who were already stealing.
              </p>
              
              <blockquote className={styles.quote}>
                <p>
                  &quot;We are not pirates. We are pirates who rob pirates. It&apos;s like being a 
                  vigilante, except instead of fighting crime we are fighting pop-up advertisements 
                  and cryptocurrency miners.&quot;
                </p>
              </blockquote>
              
              <h3>The Rules</h3>
              <div className={styles.rulesList}>
                <div className={styles.rule}>
                  <span className={styles.ruleIcon}>üö´</span>
                  <div>
                    <strong>No Puppeteer/Browser Automation</strong>
                    <p>Pure HTTP requests only. If we need a browser, we haven&apos;t cracked it properly.</p>
                  </div>
                </div>
                <div className={styles.rule}>
                  <span className={styles.ruleIcon}>üé¨</span>
                  <div>
                    <strong>No Embedding Their Players</strong>
                    <p>Their players contain ads and tracking. We extract the stream and use our own player.</p>
                  </div>
                </div>
                <div className={styles.rule}>
                  <span className={styles.ruleIcon}>üìù</span>
                  <div>
                    <strong>Document Everything</strong>
                    <p>Knowledge should be shared so others can build on it.</p>
                  </div>
                </div>
              </div>
            </motion.div>
          </section>

          {/* DLHD Section */}
          <section id="dlhd" className={styles.section}>
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
            >
              <h2 className={styles.sectionTitle}>
                <span className={styles.sectionIcon}>üì∫</span>
                DLHD Live TV
              </h2>
              
              <div className={styles.statusBadge}>
                <span className={styles.statusDot} />
                Fully Reverse Engineered - January 2026 (PoW + Timestamp Validation)
              </div>
              
              <h3>Overview</h3>
              <p>
                DLHD (daddyhd.com) provides 850+ live TV streams using HLS with AES-128 encryption. 
                As of January 2026, they use Proof-of-Work authentication with HMAC-SHA256 + MD5 
                nonce computation. The twist: timestamps must be 5-10 seconds in the past.
              </p>

              <h3>January 2026 Security Updates</h3>
              <div className={styles.flowContainer}>
                <FlowStep num={1} title="January 16: PoW Authentication" description="Added HMAC-SHA256 + MD5 nonce computation. Domain changed to dvalna.ru." />
                <FlowStep num={2} title="January 21: Timestamp Validation" description="Timestamps must be 5-10 seconds in the past. Current time fails with E11 error." />
                <FlowStep num={3} title="January 22: Server Discovery" description="Found missing servers (dokko1, ddy6). Channels 565, 770 now working." />
              </div>

              <h3>The PoW Algorithm</h3>
              <CodeBlock 
                title="Proof-of-Work Nonce Computation"
                id="dlhd-pow"
                copiedCode={copiedCode}
                onCopy={copyCode}
                code={`const HMAC_SECRET = '7f9e2a8b3c5d1e4f6a0b9c8d7e6f5a4b3c2d1e0f9a8b7c6d5e4f3a2b1c0d9e8f7';
const POW_THRESHOLD = 0x1000;

function computePoWNonce(resource, keyNumber, timestamp) {
  const hmac = HMAC_SHA256(resource, HMAC_SECRET);
  
  for (let nonce = 0; nonce < 100000; nonce++) {
    const data = hmac + resource + keyNumber + timestamp + nonce;
    const hash = MD5(data);
    const prefix = parseInt(hash.substring(0, 4), 16);
    
    if (prefix < POW_THRESHOLD) return nonce;
  }
  return null; // Failed to find valid nonce
}`}
              />

              <h3>Critical Discovery: Timestamp Validation</h3>
              <CodeBlock 
                title="Timestamp Must Be 5-10 Seconds in the Past"
                id="dlhd-timestamp"
                copiedCode={copiedCode}
                onCopy={copyCode}
                code={`// CRITICAL: DLHD requires timestamp to be 5-10 seconds in the past
// Using current time returns: {"error":"E11","message":"Timestamp out of range"}

// ‚ùå FAILS: Current time
const timestamp = Math.floor(Date.now() / 1000);

// ‚úÖ WORKS: 7 seconds in the past (middle of acceptable range)
const timestamp = Math.floor(Date.now() / 1000) - 7;

// Why 7 seconds?
// - 5 seconds: Minimum acceptable (works but close to edge)
// - 7 seconds: Optimal middle ground (recommended)
// - 10 seconds: Maximum tested (works but close to upper limit)
// - 15+ seconds: Likely to fail (too old)`}
              />

              <h3>Key Request with PoW Headers</h3>
              <CodeBlock 
                title="Complete Key Fetch Implementation"
                id="dlhd-key"
                copiedCode={copiedCode}
                onCopy={copyCode}
                code={`// 1. Compute timestamp (7 seconds in the past)
const timestamp = Math.floor(Date.now() / 1000) - 7;

// 2. Compute PoW nonce
const nonce = computePoWNonce(channelKey, keyNumber, timestamp);

// 3. Generate JWT (from player page)
const jwt = generateJWT({ resource: channelKey, keyNumber, timestamp, nonce });

// 4. Fetch key with PoW headers
const keyUrl = \`https://chevy.dvalna.ru/key/\${channelKey}/\${keyNumber}\`;
const response = await fetch(keyUrl, {
  headers: {
    'Authorization': \`Bearer \${jwt}\`,
    'X-Key-Timestamp': timestamp.toString(),
    'X-Key-Nonce': nonce.toString(),
    'Origin': 'https://epicplayplay.cfd',
    'Referer': 'https://epicplayplay.cfd/',
  }
});

// Response: 16-byte AES-128 key`}
              />

              <h3>Error Codes</h3>
              <div className={styles.errorCodes}>
                <div className={styles.errorCode}>
                  <span className={styles.errorBadge}>E9</span>
                  <div>
                    <code>Missing required headers</code>
                    <p>PoW headers not provided</p>
                  </div>
                </div>
                <div className={styles.errorCode}>
                  <span className={styles.errorBadge}>E11</span>
                  <div>
                    <code>Timestamp out of range</code>
                    <p>Timestamp too recent or too old. Use current_time - 7 seconds.</p>
                  </div>
                </div>
              </div>

              <blockquote className={styles.quote}>
                <p>
                  &quot;DLHD updated their security twice in January 2026. First PoW authentication, 
                  then timestamp validation. Each time we cracked it within hours. The cat-and-mouse 
                  game continues.&quot;
                </p>
                <cite>- Field Notes, January 21, 2026</cite>
              </blockquote>
            </motion.div>
          </section>

          {/* 111movies Section */}
          <section id="111movies" className={styles.section}>
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
            >
              <h2 className={styles.sectionTitle}>
                <span className={styles.sectionIcon}>üé¨</span>
                111movies (1movies)
              </h2>
              
              <div className={styles.statusBadge}>
                <span className={styles.statusDot} />
                Fully Reverse Engineered - December 2025
              </div>
              
              <h3>Overview</h3>
              <p>
                111movies uses a Next.js frontend with a sophisticated encoding scheme: AES-256-CBC 
                encryption, XOR obfuscation, and custom alphabet substitution. Five layers of 
                obfuscation in total.
              </p>

              <h3>The Algorithm</h3>
              <div className={styles.flowContainer}>
                <FlowStep num={1} title="Extract Page Data" description="Fetch __NEXT_DATA__.props.pageProps.data from page" />
                <FlowStep num={2} title="AES-256-CBC Encrypt" description="Encrypt with static key and IV, output as hex" />
                <FlowStep num={3} title="XOR Obfuscation" description="XOR each character with 9-byte rotating key" />
                <FlowStep num={4} title="Base64 Encode" description="UTF-8 encode, then Base64 with URL-safe characters" />
                <FlowStep num={5} title="Alphabet Substitution" description="Replace each character using shuffled alphabet" />
              </div>

              <h3>Extracted Keys</h3>
              <CodeBlock 
                title="AES Key (32 bytes) + XOR Key (9 bytes)"
                id="111-keys"
                copiedCode={copiedCode}
                onCopy={copyCode}
                code={`const AES_KEY = Buffer.from([
  3, 75, 207, 198, 39, 85, 65, 255,
  64, 89, 191, 251, 35, 214, 209, 210,
  62, 164, 155, 85, 247, 158, 167, 48,
  172, 84, 13, 18, 19, 166, 19, 57
]);

const XOR_KEY = Buffer.from([170, 162, 126, 126, 60, 255, 136, 130, 133]);

const STANDARD = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_";
const SHUFFLED = "TuzHOxl7b0RW9o_1FPV3eGfmL4Z5pD8cahBQr2U-6yvEYwngXCdJjANtqKIMiSks";`}
              />
            </motion.div>
          </section>

          {/* Flixer Section */}
          <section id="flixer" className={styles.section}>
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
            >
              <h2 className={styles.sectionTitle}>
                <span className={styles.sectionIcon}>üîê</span>
                Flixer / Hexa - WASM Cracking
              </h2>
              
              <div className={styles.statusBadge}>
                <span className={styles.statusDot} />
                Fully Reverse Engineered - December 21, 2025 (2 AM)
              </div>
              
              <h3>Overview</h3>
              <p>
                Flixer.sh uses a Rust-compiled WebAssembly module for key generation and AES-256-CTR 
                encryption with HMAC authentication. After a 12-hour reverse engineering session 
                involving Ghidra, memory forensics, and ~150 test scripts, we cracked it.
              </p>

              <h3>The Challenge</h3>
              <div className={styles.challengeGrid}>
                <div className={styles.challengeItem}>
                  <span className={styles.challengeIcon}>üîí</span>
                  <strong>WASM Encryption</strong>
                  <p>All API responses encrypted with AES-256-CTR</p>
                </div>
                <div className={styles.challengeItem}>
                  <span className={styles.challengeIcon}>üñ•Ô∏è</span>
                  <strong>Browser Fingerprinting</strong>
                  <p>Keys derived from screen, UA, timezone, canvas</p>
                </div>
                <div className={styles.challengeItem}>
                  <span className={styles.challengeIcon}>üîë</span>
                  <strong>Session Binding</strong>
                  <p>Each session generates unique 64-char hex key</p>
                </div>
                <div className={styles.challengeItem}>
                  <span className={styles.challengeIcon}>‚úÖ</span>
                  <strong>HMAC Authentication</strong>
                  <p>Requests require HMAC-SHA256 signatures</p>
                </div>
              </div>

              <h3>The Breakthrough: WASM Bundling</h3>
              <p>
                Instead of cracking the algorithm, we bundle their WASM binary directly into our 
                Cloudflare Worker. The key insight: WASM runs anywhere that provides the expected 
                browser APIs. We mock those APIs server-side.
              </p>

              <CodeBlock 
                title="WASM Import Mocking"
                id="flixer-mock"
                copiedCode={copiedCode}
                onCopy={copyCode}
                code={`const mockWindow = {
  document: {
    createElement: (tag) => tag === 'canvas' ? mockCanvas : {},
    getElementsByTagName: (tag) => tag === 'body' ? [mockBody] : [],
  },
  localStorage: {
    getItem: (key) => key === 'tmdb_session_id' ? sessionId : null,
    setItem: () => {},
  },
  navigator: { platform: 'Win32', language: 'en-US', userAgent: '...' },
  screen: { width: 1920, height: 1080, colorDepth: 24 },
  performance: { now: () => Date.now() - timestamp },
};`}
              />

              <blockquote className={styles.quote}>
                <p>
                  &quot;Sometimes the best way to crack encryption is to not crack it at all. Just run 
                  their code in your environment with mocked inputs. If you can&apos;t beat the algorithm, 
                  become the algorithm.&quot;
                </p>
                <cite>- Field Notes, December 21, 2025, 2:00 AM</cite>
              </blockquote>
            </motion.div>
          </section>

          {/* VidSrc Section */}
          <section id="vidsrc" className={styles.section}>
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
            >
              <h2 className={styles.sectionTitle}>
                <span className={styles.sectionIcon}>üì°</span>
                VidSrc - Static Decoders
              </h2>
              
              <div className={styles.statusBadge}>
                <span className={styles.statusDot} />
                Working - Primary Provider
              </div>
              
              <h3>Encoding Formats</h3>
              <CodeBlock 
                title="HEX Format (Primary)"
                id="vidsrc-hex"
                copiedCode={copiedCode}
                onCopy={copyCode}
                code={`// Algorithm: Reverse ‚Üí Subtract 1 from each char ‚Üí Hex decode
function decodeHexFormat(encoded) {
  const reversed = encoded.split('').reverse().join('');
  let adjusted = '';
  for (let i = 0; i < reversed.length; i++) {
    adjusted += String.fromCharCode(reversed.charCodeAt(i) - 1);
  }
  const hexClean = adjusted.replace(/[^0-9a-fA-F]/g, '');
  let decoded = '';
  for (let i = 0; i < hexClean.length; i += 2) {
    decoded += String.fromCharCode(parseInt(hexClean.substr(i, 2), 16));
  }
  return decoded;
}`}
              />
            </motion.div>
          </section>

          {/* Videasy Section */}
          <section id="videasy" className={styles.section}>
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
            >
              <h2 className={styles.sectionTitle}>
                <span className={styles.sectionIcon}>üåç</span>
                Videasy - Multi-Language
              </h2>
              
              <div className={styles.statusBadge}>
                <span className={styles.statusDot} />
                Working - 17 Servers, 8 Languages
              </div>
              
              <h3>Available Servers</h3>
              <div className={styles.serverGrid}>
                <div className={styles.serverGroup}>
                  <h4>English Servers</h4>
                  <div className={styles.serverList}>
                    <span>Neon</span><span>Sage</span><span>Cypher</span><span>Yoru</span>
                    <span>Reyna</span><span>Omen</span><span>Breach</span><span>Vyse</span>
                  </div>
                </div>
                <div className={styles.serverGroup}>
                  <h4>International</h4>
                  <div className={styles.serverList}>
                    <span>üá©üá™ German</span><span>üáÆüáπ Italian</span><span>üá´üá∑ French</span>
                    <span>üá™üá∏ Spanish</span><span>üáßüá∑ Portuguese</span>
                  </div>
                </div>
              </div>
            </motion.div>
          </section>

          {/* AnimeKai Section */}
          <section id="animekai" className={styles.section}>
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
            >
              <h2 className={styles.sectionTitle}>
                <span className={styles.sectionIcon}>üéå</span>
                AnimeKai - Native Crypto Breakthrough
              </h2>
              
              <div className={styles.statusBadge}>
                <span className={styles.statusDot} />
                Fully Reverse Engineered - 183 Substitution Tables
              </div>
              
              <h3>Overview</h3>
              <p>
                AnimeKai uses a position-dependent substitution cipher with 183 unique tables‚Äîone 
                for each character position. We reverse engineered all tables and now have 100% 
                native encryption/decryption with zero external dependencies.
              </p>

              <h3>Cipher Structure</h3>
              <div className={styles.flowContainer}>
                <FlowStep num={1} title="21-Byte Header" description="Fixed header: c509bdb497cbc06873ff412af12fd8007624c29faa (hex)" />
                <FlowStep num={2} title="Constant Padding" description="Positions 1,2,3,4,5,6,8,9,10,12,14,16,18 have fixed values" />
                <FlowStep num={3} title="Position Mapping" description="Plaintext position 0‚Üí0, 1‚Üí7, 2‚Üí11, 3‚Üí13, 4‚Üí15, 5‚Üí17, 6‚Üí19, 7+‚Üí20+" />
                <FlowStep num={4} title="Substitution Tables" description="183 tables, each mapping 78 characters to unique bytes" />
                <FlowStep num={5} title="URL-Safe Base64" description="Output encoded with - and _ instead of + and /" />
              </div>

              <h3>Native Encryption</h3>
              <CodeBlock 
                title="encryptKai() Implementation"
                id="animekai-encrypt"
                copiedCode={copiedCode}
                onCopy={copyCode}
                code={`export function encryptKai(plaintext: string): string {
  // Start with fixed header
  const result = Buffer.alloc(HEADER_LEN + 20 + plaintext.length);
  HEADER.copy(result, 0);
  
  // Fill constant padding bytes
  for (const [pos, val] of Object.entries(CONSTANT_BYTES)) {
    result[HEADER_LEN + parseInt(pos)] = val;
  }
  
  // Encrypt each character using position-specific table
  for (let i = 0; i < plaintext.length; i++) {
    const char = plaintext[i];
    const table = ENCRYPT_TABLES[i];
    const cipherPos = getCipherPosition(i);
    result[HEADER_LEN + cipherPos] = table[char] ?? 0xd4;
  }
  
  return urlSafeBase64Encode(result);
}`}
              />

              <h3>Complete API Flow</h3>
              <div className={styles.flowContainer}>
                <FlowStep num={1} title="ID Mapping" description="TMDB ID ‚Üí MAL/AniList ID via ARM API" />
                <FlowStep num={2} title="Search" description="encryptKai(malId) ‚Üí POST /ajax/anime/search" />
                <FlowStep num={3} title="Episodes" description="encryptKai(kai_id) ‚Üí GET /ajax/episodes" />
                <FlowStep num={4} title="Servers" description="encryptKai(token) ‚Üí GET /ajax/links (sub/dub)" />
                <FlowStep num={5} title="Embed URL" description="encryptKai(lid) ‚Üí decryptKai(response) ‚Üí MegaUp URL" />
                <FlowStep num={6} title="Stream" description="MegaUp URL ‚Üí native decryption ‚Üí HLS m3u8" />
              </div>

              <blockquote className={styles.quote}>
                <p>
                  &quot;The cipher looked complex at first‚Äî183 different substitution tables! But once 
                  we realized it was position-dependent with no key derivation, building the tables 
                  was just tedious, not hard.&quot;
                </p>
                <cite>- Field Notes, December 2025</cite>
              </blockquote>
            </motion.div>
          </section>

          {/* MegaUp Section */}
          <section id="megaup" className={styles.section}>
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
            >
              <h2 className={styles.sectionTitle}>
                <span className={styles.sectionIcon}>üîì</span>
                MegaUp - Stream Cipher Cracked
              </h2>
              
              <div className={styles.statusBadge}>
                <span className={styles.statusDot} />
                Fully Reverse Engineered - Pre-computed Keystream
              </div>
              
              <h3>Overview</h3>
              <p>
                MegaUp is the CDN used by AnimeKai. Their <code>/media/</code> endpoint returns 
                encrypted JSON. Key insight: For a fixed User-Agent, the keystream is constant. 
                We pre-computed a 521-byte keystream for our fixed UA.
              </p>

              <h3>Pre-Computed Keystream</h3>
              <CodeBlock 
                title="Fixed UA + Keystream"
                id="megaup-keystream"
                copiedCode={copiedCode}
                onCopy={copyCode}
                code={`// Fixed User-Agent for all MegaUp requests
export const MEGAUP_USER_AGENT = 
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36';

// Pre-computed 521-byte keystream for this UA
const MEGAUP_KEYSTREAM_HEX = 
  'dece4f239861eb1c7d83f86c2fb5d27e557a3fd2696781674b986f9ed5d55cb0' +
  '28abc5e482a02a7c03d7ee811eb7bd6ad1dba549a20e53f564208b9d5d2e28b0' +
  '797f6c6e547b5ce423bbc44be596b6ad536b9edea25a6bf97ed7fe1f36298ff1' +
  // ... 521 bytes total
  ;`}
              />

              <h3>Native Decryption</h3>
              <CodeBlock 
                title="decryptMegaUp() Implementation"
                id="megaup-decrypt"
                copiedCode={copiedCode}
                onCopy={copyCode}
                code={`export function decryptMegaUp(encryptedBase64: string): string {
  const keystream = Buffer.from(MEGAUP_KEYSTREAM_HEX, 'hex');
  
  // Convert from URL-safe base64
  const base64 = encryptedBase64.replace(/-/g, '+').replace(/_/g, '/');
  const encBytes = Buffer.from(base64, 'base64');
  
  // XOR decrypt with pre-computed keystream
  const decBytes = Buffer.alloc(encBytes.length);
  for (let i = 0; i < encBytes.length; i++) {
    decBytes[i] = encBytes[i] ^ keystream[i];
  }
  
  return decBytes.toString('utf8');
}`}
              />

              <blockquote className={styles.quote}>
                <p>
                  &quot;We spent days trying to reverse engineer the full keystream generation algorithm. 
                  Then realized: if the keystream is constant for a fixed UA, we don&apos;t need to 
                  understand HOW it&apos;s generated‚Äîjust WHAT it is. Pre-compute once, use forever.&quot;
                </p>
                <cite>- Field Notes, December 2025</cite>
              </blockquote>
            </motion.div>
          </section>

          {/* Proxy Architecture Section */}
          <section id="proxy-architecture" className={styles.section}>
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
            >
              <h2 className={styles.sectionTitle}>
                <span className={styles.sectionIcon}>üîÑ</span>
                Proxy Architecture
              </h2>
              
              <div className={styles.statusBadge}>
                <span className={styles.statusDot} />
                Production Ready - Multi-Layer
              </div>
              
              <h3>The Problem</h3>
              <p>
                Multiple CDNs block datacenter IPs and reject requests with Origin headers 
                (which browsers add automatically to XHR).
              </p>

              <h3>Multi-Layer Proxy Solution</h3>
              <div className={styles.architectureDiagram}>
                <div className={styles.archLayer}>
                  <span className={styles.archIcon}>üåê</span>
                  <span>Browser (XHR with Origin)</span>
                </div>
                <div className={styles.archArrow}>‚Üì</div>
                <div className={styles.archLayer}>
                  <span className={styles.archIcon}>‚ñ≤</span>
                  <span>Vercel API Route</span>
                </div>
                <div className={styles.archArrow}>‚Üì</div>
                <div className={styles.archLayer}>
                  <span className={styles.archIcon}>‚òÅÔ∏è</span>
                  <span>Cloudflare Worker</span>
                </div>
                <div className={styles.archArrow}>‚Üì</div>
                <div className={styles.archLayer + ' ' + styles.archHighlight}>
                  <span className={styles.archIcon}>üè†</span>
                  <span>Raspberry Pi (Residential IP)</span>
                </div>
                <div className={styles.archArrow}>‚Üì</div>
                <div className={styles.archLayer}>
                  <span className={styles.archIcon}>üì∫</span>
                  <span>CDN ‚Üí HLS Stream</span>
                </div>
              </div>

              <CodeBlock 
                title="CDN Detection & Routing"
                id="proxy-cdn"
                copiedCode={copiedCode}
                onCopy={copyCode}
                code={`// MegaUp CDN (AnimeKai) - requires residential IP
function isMegaUpCdnUrl(url) {
  return url.includes('megaup') || 
         url.includes('hub26link') || 
         url.includes('app28base');
}

// 1movies CDN - requires residential IP
function is1moviesCdnUrl(url) {
  return url.match(/p\\.\\d+\\.workers\\.dev/);
}

// Route decision
if (isAnimeKai || isMegaUpCdn || is1moviesCdn) {
  return getAnimeKaiProxyUrl(url); // ‚Üí RPI residential proxy
} else {
  return getStreamProxyUrl(url);   // ‚Üí direct Cloudflare Worker
}`}
              />
            </motion.div>
          </section>

          {/* Techniques Section */}
          <section id="techniques" className={styles.section}>
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
            >
              <h2 className={styles.sectionTitle}>
                <span className={styles.sectionIcon}>üõ†Ô∏è</span>
                Common Techniques
              </h2>
              
              <div className={styles.techniqueGrid}>
                <div className={styles.techniqueCard}>
                  <h4>String Array Obfuscation</h4>
                  <p>Strings stored in array, accessed via index. Array often rotated or encoded.</p>
                  <code>const a = atob(_0x1234[0]);</code>
                </div>
                <div className={styles.techniqueCard}>
                  <h4>Control Flow Flattening</h4>
                  <p>Code restructured into switch inside while loop, hard to follow execution.</p>
                  <code>while(true) switch(state) ...</code>
                </div>
                <div className={styles.techniqueCard}>
                  <h4>XOR Encryption</h4>
                  <p>Each character XORed with key byte. Simple but effective.</p>
                  <code>char ^ key[i % key.length]</code>
                </div>
                <div className={styles.techniqueCard}>
                  <h4>Custom Base64</h4>
                  <p>Standard alphabet shuffled to break decoders.</p>
                  <code>ABCDEFGHIJKLMabc... ‚Üí shuffled</code>
                </div>
                <div className={styles.techniqueCard}>
                  <h4>Proof-of-Work</h4>
                  <p>Computational challenge to prevent automated requests.</p>
                  <code>MD5(data)[0:4] &lt; threshold</code>
                </div>
                <div className={styles.techniqueCard}>
                  <h4>WASM Encryption</h4>
                  <p>Crypto logic compiled to WebAssembly. Harder to reverse.</p>
                  <code>Rust ‚Üí WASM ‚Üí AES-256-CTR</code>
                </div>
              </div>
            </motion.div>
          </section>

          {/* Tools Section */}
          <section id="tools" className={styles.section}>
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
            >
              <h2 className={styles.sectionTitle}>
                <span className={styles.sectionIcon}>üß∞</span>
                Tools & Methods
              </h2>
              
              <h3>Essential Tools</h3>
              <div className={styles.toolsGrid}>
                <div className={styles.toolCard}>
                  <div className={styles.toolIcon}>üîç</div>
                  <h4>Browser DevTools</h4>
                  <p>Network tab, Sources debugging, Console testing. Set breakpoints on XHR/fetch.</p>
                </div>
                <div className={styles.toolCard}>
                  <div className={styles.toolIcon}>üßπ</div>
                  <h4>de4js</h4>
                  <p>Online JavaScript deobfuscator. Good starting point for most obfuscation.</p>
                </div>
                <div className={styles.toolCard}>
                  <div className={styles.toolIcon}>üî¨</div>
                  <h4>Ghidra</h4>
                  <p>NSA&apos;s reverse engineering tool. Essential for WASM binary analysis.</p>
                </div>
                <div className={styles.toolCard}>
                  <div className={styles.toolIcon}>üç≥</div>
                  <h4>CyberChef</h4>
                  <p>Swiss army knife for encoding/decoding. Base64, XOR, AES, hex, everything.</p>
                </div>
              </div>

              <h3>Common Pitfalls</h3>
              <div className={styles.pitfallsList}>
                <div className={styles.pitfall}>
                  <span className={styles.pitfallIcon}>‚ö†Ô∏è</span>
                  <strong>Missing Headers</strong> - APIs often require <code>X-Requested-With: XMLHttpRequest</code>
                </div>
                <div className={styles.pitfall}>
                  <span className={styles.pitfallIcon}>‚è∞</span>
                  <strong>Timestamp Validation</strong> - Some APIs require timestamps in the past (DLHD: 5-10 seconds)
                </div>
                <div className={styles.pitfall}>
                  <span className={styles.pitfallIcon}>üåê</span>
                  <strong>IP Restrictions</strong> - CDNs may block datacenter IPs, need residential proxy
                </div>
                <div className={styles.pitfall}>
                  <span className={styles.pitfallIcon}>üîó</span>
                  <strong>Origin Header</strong> - Browser XHR adds Origin automatically, some CDNs reject it
                </div>
              </div>
            </motion.div>
          </section>

          {/* Contributing Section */}
          <section id="contribute" className={styles.section}>
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
            >
              <h2 className={styles.sectionTitle}>
                <span className={styles.sectionIcon}>ü§ù</span>
                Contributing
              </h2>
              
              <p>
                Found a new provider? Cracked an obfuscation we haven&apos;t documented? We&apos;d love 
                to hear about it.
              </p>
              
              <h3>What We&apos;re Looking For</h3>
              <div className={styles.contributionList}>
                <div className={styles.contributionItem}>
                  <span>‚ú®</span> New provider extraction methods
                </div>
                <div className={styles.contributionItem}>
                  <span>üîÑ</span> Updates when providers change their obfuscation
                </div>
                <div className={styles.contributionItem}>
                  <span>üßπ</span> Better/cleaner implementations of existing extractors
                </div>
                <div className={styles.contributionItem}>
                  <span>üìù</span> Documentation improvements
                </div>
                <div className={styles.contributionItem}>
                  <span>üîì</span> CDN bypass techniques
                </div>
              </div>

              <h3>Guidelines</h3>
              <div className={styles.guidelinesList}>
                <div className={styles.guideline}>
                  <span className={styles.guidelineIcon}>üö´</span>
                  No Puppeteer/browser automation - pure HTTP only
                </div>
                <div className={styles.guideline}>
                  <span className={styles.guidelineIcon}>üìñ</span>
                  Document your methodology, not just the code
                </div>
                <div className={styles.guideline}>
                  <span className={styles.guidelineIcon}>üîë</span>
                  Include the keys/constants you extracted
                </div>
                <div className={styles.guideline}>
                  <span className={styles.guidelineIcon}>üß™</span>
                  Test with multiple content IDs to ensure reliability
                </div>
              </div>

              <div className={styles.ctaBox}>
                <p>
                  This documentation is part of the Flyx project. Check out the full{' '}
                  <Link href="/about" className={styles.ctaLink}>About page</Link> for the complete 
                  story of how we built an ethical streaming platform by reverse engineering the 
                  unethical ones.
                </p>
              </div>
            </motion.div>
          </section>

        </main>
      </div>
    </div>
  );
}
