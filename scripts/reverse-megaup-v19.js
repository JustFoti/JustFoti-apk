#!/usr/bin/env node
/**
 * Reverse engineer MegaUp encryption - v19
 * 
 * Key finding: Keystrams for different videos start the same (first 32 bytes)
 * but then diverge. This suggests a cipher with feedback.
 * 
 * Possible algorithms:
 * 1. CFB (Cipher Feedback) - keystream depends on previous ciphertext
 * 2. OFB (Output Feedback) - keystream depends on previous keystream
 * 3. Custom feedback cipher
 * 
 * Let's test CFB mode.
 */

const crypto = require('crypto');

const ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36';

async function testDecryption(encrypted, agent) {
  const response = await fetch('https://enc-dec.app/api/dec-mega', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text: encrypted, agent }),
  });
  return await response.json();
}

async function main() {
  // Get two different videos
  const videoIds = ['jIrrLzj-WS2JcOLzF79O5xvpCQ', 'k5OoeWapWS2JcOLzF79O5xvpCQ'];
  const baseUrl = 'https://megaup22.online';
  
  const data = [];
  
  for (const videoId of videoIds) {
    const mediaResponse = await fetch(`${baseUrl}/media/${videoId}`, {
      headers: { 'User-Agent': ua, 'Referer': `${baseUrl}/e/${videoId}` },
    });
    const mediaData = await mediaResponse.json();
    const encrypted = mediaData.result;
    
    const encBytes = Buffer.from(encrypted.replace(/-/g, '+').replace(/_/g, '/'), 'base64');
    
    const decResult = await testDecryption(encrypted, ua);
    const decrypted = typeof decResult.result === 'string' ? decResult.result : JSON.stringify(decResult.result);
    const decBytes = Buffer.from(decrypted, 'utf8');
    
    const keystream = [];
    for (let i = 0; i < decBytes.length; i++) {
      keystream.push(encBytes[i] ^ decBytes[i]);
    }
    
    data.push({ videoId, encBytes, decBytes, keystream });
  }
  
  console.log('=== Comparing two videos ===');
  console.log('Video 1 keystream (first 64):', Buffer.from(data[0].keystream.slice(0, 64)).toString('hex'));
  console.log('Video 2 keystream (first 64):', Buffer.from(data[1].keystream.slice(0, 64)).toString('hex'));
  
  // Find where keystrams diverge
  let divergeAt = -1;
  for (let i = 0; i < Math.min(data[0].keystream.length, data[1].keystream.length); i++) {
    if (data[0].keystream[i] !== data[1].keystream[i]) {
      divergeAt = i;
      break;
    }
  }
  console.log(`Keystrams diverge at position: ${divergeAt}`);
  
  // Check what's different at that position
  if (divergeAt >= 0) {
    console.log(`\nAt position ${divergeAt}:`);
    console.log(`  Video 1: enc=${data[0].encBytes[divergeAt].toString(16)} dec=${data[0].decBytes[divergeAt].toString(16)} ks=${data[0].keystream[divergeAt].toString(16)}`);
    console.log(`  Video 2: enc=${data[1].encBytes[divergeAt].toString(16)} dec=${data[1].decBytes[divergeAt].toString(16)} ks=${data[1].keystream[divergeAt].toString(16)}`);
    
    // Check if the divergence is related to the ciphertext
    console.log(`\nCiphertext at position ${divergeAt - 1}:`);
    console.log(`  Video 1: ${data[0].encBytes[divergeAt - 1].toString(16)}`);
    console.log(`  Video 2: ${data[1].encBytes[divergeAt - 1].toString(16)}`);
  }
  
  // Test CFB hypothesis: keystream[i] = E(keystream[i-1] XOR ciphertext[i-1])
  // Or more likely: keystream[i] = E(ciphertext[i-1])
  
  console.log('\n=== Testing CFB hypothesis ===');
  
  // In CFB mode, the keystream is generated by encrypting the previous ciphertext block
  // keystream[i] = AES(key, ciphertext[i-16:i])
  
  // Let's see if the keystream changes when we change a ciphertext byte
  const modified = Buffer.from(data[0].encBytes);
  modified[32] ^= 0x01; // Modify byte 32 (after the first block)
  
  const modifiedBase64 = modified.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
  const modResult = await testDecryption(modifiedBase64, ua);
  
  if (modResult.status === 200) {
    const modDecrypted = typeof modResult.result === 'string' ? modResult.result : JSON.stringify(modResult.result);
    const modDecBytes = Buffer.from(modDecrypted, 'utf8');
    
    // Find which bytes changed
    const changes = [];
    for (let i = 0; i < Math.min(modDecBytes.length, data[0].decBytes.length); i++) {
      if (modDecBytes[i] !== data[0].decBytes[i]) {
        changes.push(i);
      }
    }
    console.log(`Modified byte 32: ${changes.length} plaintext bytes changed`);
    console.log(`Changed positions: ${changes.slice(0, 20).join(', ')}${changes.length > 20 ? '...' : ''}`);
    
    // In CFB mode, modifying ciphertext byte i should:
    // - Change plaintext byte i (direct XOR)
    // - Change all subsequent bytes (feedback)
  } else {
    console.log('Modified decryption failed:', modResult.error);
  }
  
  // Let's also test if the keystream is generated block-by-block
  console.log('\n=== Testing block structure ===');
  
  // Check if keystream has 16-byte block structure
  for (const blockSize of [8, 16, 32]) {
    let blockMatches = 0;
    for (let i = blockSize; i < data[0].keystream.length; i++) {
      // In OFB mode, keystream[i] = keystream[i - blockSize] after some transformation
      // Let's check if there's any relationship
    }
    
    // Check if keystream blocks are related to ciphertext blocks
    console.log(`\nBlock size ${blockSize}:`);
    console.log(`  Keystream block 0: ${Buffer.from(data[0].keystream.slice(0, blockSize)).toString('hex')}`);
    console.log(`  Keystream block 1: ${Buffer.from(data[0].keystream.slice(blockSize, blockSize * 2)).toString('hex')}`);
    console.log(`  Ciphertext block 0: ${data[0].encBytes.slice(0, blockSize).toString('hex')}`);
    console.log(`  Ciphertext block 1: ${data[0].encBytes.slice(blockSize, blockSize * 2).toString('hex')}`);
  }
}

main().catch(console.error);
