#!/usr/bin/env node
/**
 * Reverse engineer MegaUp encryption - v18
 * 
 * Let's verify the exact relationship between encrypted and decrypted data.
 */

const crypto = require('crypto');

const ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36';

async function testDecryption(encrypted, agent) {
  const response = await fetch('https://enc-dec.app/api/dec-mega', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text: encrypted, agent }),
  });
  return await response.json();
}

async function main() {
  // Get real encrypted data
  const videoId = 'jIrrLzj-WS2JcOLzF79O5xvpCQ';
  const baseUrl = 'https://megaup22.online';
  
  const mediaResponse = await fetch(`${baseUrl}/media/${videoId}`, {
    headers: { 'User-Agent': ua, 'Referer': `${baseUrl}/e/${videoId}` },
  });
  const mediaData = await mediaResponse.json();
  const encrypted = mediaData.result;
  
  const encBytes = Buffer.from(encrypted.replace(/-/g, '+').replace(/_/g, '/'), 'base64');
  
  // Get decrypted
  const decResult = await testDecryption(encrypted, ua);
  const decrypted = typeof decResult.result === 'string' ? decResult.result : JSON.stringify(decResult.result);
  const decBytes = Buffer.from(decrypted, 'utf8');
  
  console.log('Encrypted bytes:', encBytes.length);
  console.log('Decrypted bytes:', decBytes.length);
  console.log('Difference:', encBytes.length - decBytes.length);
  
  // The decrypted data is 521 bytes, encrypted is 717 bytes
  // Difference is 196 bytes
  
  // Let's verify: if we XOR encrypted[0:521] with decrypted, we get the keystream
  console.log('\n=== XOR Analysis ===');
  
  const keystream = [];
  for (let i = 0; i < decBytes.length; i++) {
    keystream.push(encBytes[i] ^ decBytes[i]);
  }
  
  console.log('Keystream (first 64):', Buffer.from(keystream.slice(0, 64)).toString('hex'));
  
  // Now let's verify this keystream by encrypting the plaintext
  const reEncrypted = [];
  for (let i = 0; i < decBytes.length; i++) {
    reEncrypted.push(decBytes[i] ^ keystream[i]);
  }
  
  // Check if re-encrypted matches original
  let matches = 0;
  for (let i = 0; i < decBytes.length; i++) {
    if (reEncrypted[i] === encBytes[i]) matches++;
  }
  console.log(`Re-encryption matches: ${matches}/${decBytes.length}`);
  
  // Perfect! The XOR relationship is confirmed.
  // Now we need to find how the keystream is generated.
  
  // Let's analyze the keystream more carefully
  console.log('\n=== Keystream Analysis ===');
  
  // Check if keystream has any structure
  // Try to find if it's generated by a PRNG seeded with UA
  
  // Test: Is the keystream the same for different videos with the same UA?
  console.log('\n=== Testing keystream consistency ===');
  
  const videoId2 = 'k5OoeWapWS2JcOLzF79O5xvpCQ'; // Different video
  
  const mediaResponse2 = await fetch(`${baseUrl}/media/${videoId2}`, {
    headers: { 'User-Agent': ua, 'Referer': `${baseUrl}/e/${videoId2}` },
  });
  const mediaData2 = await mediaResponse2.json();
  const encrypted2 = mediaData2.result;
  
  const encBytes2 = Buffer.from(encrypted2.replace(/-/g, '+').replace(/_/g, '/'), 'base64');
  
  const decResult2 = await testDecryption(encrypted2, ua);
  const decrypted2 = typeof decResult2.result === 'string' ? decResult2.result : JSON.stringify(decResult2.result);
  const decBytes2 = Buffer.from(decrypted2, 'utf8');
  
  const keystream2 = [];
  for (let i = 0; i < decBytes2.length; i++) {
    keystream2.push(encBytes2[i] ^ decBytes2[i]);
  }
  
  console.log('Keystream 1 (first 32):', Buffer.from(keystream.slice(0, 32)).toString('hex'));
  console.log('Keystream 2 (first 32):', Buffer.from(keystream2.slice(0, 32)).toString('hex'));
  
  // Check how many bytes match
  let ksMatches = 0;
  const minLen = Math.min(keystream.length, keystream2.length);
  for (let i = 0; i < minLen; i++) {
    if (keystream[i] === keystream2[i]) ksMatches++;
  }
  console.log(`Keystream match: ${ksMatches}/${minLen} (${(ksMatches/minLen*100).toFixed(1)}%)`);
  
  // If keystrams are the same, the encryption uses a fixed keystream per UA
  // If different, the keystream depends on something else (like the video ID or timestamp)
  
  // Let's also check the "extra" bytes at the end of encrypted data
  console.log('\n=== Extra bytes analysis ===');
  
  const extraBytes = encBytes.slice(decBytes.length);
  console.log('Extra bytes length:', extraBytes.length);
  console.log('Extra bytes (first 32):', extraBytes.slice(0, 32).toString('hex'));
  console.log('Extra bytes (last 32):', extraBytes.slice(-32).toString('hex'));
  
  // Check if extra bytes are related to keystream
  const extraKeystream = keystream.slice(-extraBytes.length);
  console.log('Keystream end (32):', Buffer.from(keystream.slice(-32)).toString('hex'));
  
  // Maybe the extra bytes are the continuation of the keystream?
  // Or maybe they're padding/metadata
}

main().catch(console.error);
