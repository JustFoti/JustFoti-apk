#!/usr/bin/env node
/**
 * Reverse engineer MegaUp encryption - v28
 * 
 * Let's focus on the INITIAL keystream (before any plaintext divergence)
 * and try to understand how it's derived from the UA.
 */

const crypto = require('crypto');

const ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36';

async function testDecryption(encrypted, agent) {
  const response = await fetch('https://enc-dec.app/api/dec-mega', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text: encrypted, agent }),
  });
  return await response.json();
}

async function main() {
  const videoId = 'jIrrLzj-WS2JcOLzF79O5xvpCQ';
  const baseUrl = 'https://megaup22.online';
  
  const mediaResponse = await fetch(`${baseUrl}/media/${videoId}`, {
    headers: { 'User-Agent': ua, 'Referer': `${baseUrl}/e/${videoId}` },
  });
  const mediaData = await mediaResponse.json();
  const encrypted = mediaData.result;
  
  const encBytes = Buffer.from(encrypted.replace(/-/g, '+').replace(/_/g, '/'), 'base64');
  
  const decResult = await testDecryption(encrypted, ua);
  const decrypted = typeof decResult.result === 'string' ? decResult.result : JSON.stringify(decResult.result);
  const decBytes = Buffer.from(decrypted, 'utf8');
  
  // Extract keystream
  const keystream = [];
  for (let i = 0; i < decBytes.length; i++) {
    keystream.push(encBytes[i] ^ decBytes[i]);
  }
  
  console.log('UA:', ua);
  console.log('UA length:', ua.length);
  console.log('\nKeystream (first 64 bytes):');
  console.log(Buffer.from(keystream.slice(0, 64)).toString('hex'));
  
  // The keystream is consistent for the first 33 bytes across different videos
  // Let's focus on understanding those first 33 bytes
  
  console.log('\n=== Analyzing first 33 keystream bytes ===');
  
  const ks33 = keystream.slice(0, 33);
  console.log('First 33 keystream bytes:', Buffer.from(ks33).toString('hex'));
  
  // Try to find relationship with UA
  const uaBytes = Buffer.from(ua);
  
  // Check if keystream[i] = f(UA[i % UA.length])
  console.log('\nChecking keystream[i] vs UA[i % UA.length]:');
  for (let i = 0; i < 33; i++) {
    const ks = ks33[i];
    const uaByte = uaBytes[i % uaBytes.length];
    const xor = ks ^ uaByte;
    const add = (ks + uaByte) & 0xFF;
    const sub = (ks - uaByte + 256) & 0xFF;
    console.log(`[${i.toString().padStart(2)}] ks=${ks.toString(16).padStart(2, '0')} ua=${uaByte.toString(16).padStart(2, '0')}('${String.fromCharCode(uaByte)}') xor=${xor.toString(16).padStart(2, '0')} add=${add.toString(16).padStart(2, '0')} sub=${sub.toString(16).padStart(2, '0')}`);
  }
  
  // Check if there's a pattern in the XOR values
  const xorValues = ks33.map((ks, i) => ks ^ uaBytes[i % uaBytes.length]);
  console.log('\nXOR values:', Buffer.from(xorValues).toString('hex'));
  
  // Check if XOR values form a pattern
  console.log('\nChecking if XOR values have a pattern:');
  for (const period of [1, 2, 4, 8, 16, 32]) {
    let matches = 0;
    for (let i = period; i < xorValues.length; i++) {
      if (xorValues[i] === xorValues[i % period]) matches++;
    }
    console.log(`Period ${period}: ${matches}/${xorValues.length - period} matches`);
  }
  
  // Try to find if keystream is generated by a PRNG seeded with UA
  console.log('\n=== Testing PRNG models ===');
  
  // Model 1: Simple LCG seeded with sum of UA bytes
  const uaSum = uaBytes.reduce((a, b) => a + b, 0);
  console.log(`UA byte sum: ${uaSum}`);
  
  // Model 2: RC4 with UA as key
  console.log('\nRC4 with UA as key:');
  const rc4Ks = generateRC4Keystream(ua, 33);
  let rc4Matches = 0;
  for (let i = 0; i < 33; i++) {
    if (rc4Ks[i] === ks33[i]) rc4Matches++;
  }
  console.log(`Matches: ${rc4Matches}/33`);
  console.log('RC4 keystream:', Buffer.from(rc4Ks).toString('hex'));
  
  // Model 3: AES-CTR with UA-derived key
  console.log('\nAES-CTR with SHA256(UA) key and zero IV:');
  const sha256Key = crypto.createHash('sha256').update(ua).digest();
  const zeroIV = Buffer.alloc(16, 0);
  const cipher = crypto.createCipheriv('aes-256-ctr', sha256Key, zeroIV);
  const aesKs = cipher.update(Buffer.alloc(33, 0));
  let aesMatches = 0;
  for (let i = 0; i < 33; i++) {
    if (aesKs[i] === ks33[i]) aesMatches++;
  }
  console.log(`Matches: ${aesMatches}/33`);
  console.log('AES keystream:', aesKs.toString('hex'));
  
  // Model 4: Try different hash-based approaches
  console.log('\n=== Testing hash-based models ===');
  
  // Maybe keystream[i] = HASH(UA + i)[0]
  for (let i = 0; i < 5; i++) {
    const hash = crypto.createHash('md5').update(ua + i).digest();
    console.log(`MD5(UA + ${i})[0]: ${hash[0].toString(16)} vs ks[${i}]: ${ks33[i].toString(16)}`);
  }
  
  // Maybe keystream = HASH(UA) repeated
  const md5UA = crypto.createHash('md5').update(ua).digest();
  console.log('\nMD5(UA):', md5UA.toString('hex'));
  console.log('Keystream[0:16]:', Buffer.from(ks33.slice(0, 16)).toString('hex'));
  
  const sha1UA = crypto.createHash('sha1').update(ua).digest();
  console.log('\nSHA1(UA):', sha1UA.toString('hex'));
  console.log('Keystream[0:20]:', Buffer.from(ks33.slice(0, 20)).toString('hex'));
  
  // Try XOR with position
  console.log('\n=== Testing position-based transformations ===');
  
  // keystream[i] = S[i] XOR UA[i % UA.length]
  // where S is some fixed sequence
  const S = ks33.map((ks, i) => ks ^ uaBytes[i % uaBytes.length]);
  console.log('S = keystream XOR UA:', Buffer.from(S).toString('hex'));
  
  // Check if S is related to position
  console.log('\nS[i] vs i:');
  for (let i = 0; i < 10; i++) {
    console.log(`S[${i}] = ${S[i].toString(16).padStart(2, '0')}, i = ${i.toString(16).padStart(2, '0')}, S[i] XOR i = ${(S[i] ^ i).toString(16).padStart(2, '0')}`);
  }
}

function generateRC4Keystream(key, length) {
  const S = new Array(256);
  for (let i = 0; i < 256; i++) S[i] = i;
  
  let j = 0;
  for (let i = 0; i < 256; i++) {
    j = (j + S[i] + key.charCodeAt(i % key.length)) % 256;
    [S[i], S[j]] = [S[j], S[i]];
  }
  
  const keystream = [];
  let i = 0;
  j = 0;
  for (let k = 0; k < length; k++) {
    i = (i + 1) % 256;
    j = (j + S[i]) % 256;
    [S[i], S[j]] = [S[j], S[i]];
    keystream.push(S[(S[i] + S[j]) % 256]);
  }
  return keystream;
}

main().catch(console.error);
