#!/usr/bin/env node
/**
 * Reverse engineer MegaUp encryption - v9
 * 
 * The keystream changes based on UA but in a predictable way.
 * Let's analyze the byte-by-byte relationship.
 */

const crypto = require('crypto');

const videoId = 'jIrrLzj-WS2JcOLzF79O5xvpCQ';
const baseUrl = 'https://megaup22.online';

// Two UAs that differ by one character
const ua1 = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36';
const ua2 = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36';

async function getKeystreamForUA(ua) {
  const mediaResponse = await fetch(`${baseUrl}/media/${videoId}`, {
    headers: { 'User-Agent': ua, 'Referer': `${baseUrl}/e/${videoId}` },
  });
  const mediaData = await mediaResponse.json();
  const encrypted = mediaData.result;
  
  const decResponse = await fetch('https://enc-dec.app/api/dec-mega', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text: encrypted, agent: ua }),
  });
  const decResult = await decResponse.json();
  const decrypted = typeof decResult.result === 'string' ? decResult.result : JSON.stringify(decResult.result);
  
  const encBytes = Buffer.from(encrypted.replace(/-/g, '+').replace(/_/g, '/'), 'base64');
  const decBytes = Buffer.from(decrypted, 'utf8');
  
  const keystream = [];
  for (let i = 0; i < Math.min(encBytes.length, decBytes.length); i++) {
    keystream.push(encBytes[i] ^ decBytes[i]);
  }
  
  return keystream;
}

async function main() {
  console.log('Fetching keystrams for two similar UAs...\n');
  
  const ks1 = await getKeystreamForUA(ua1);
  const ks2 = await getKeystreamForUA(ua2);
  
  console.log('UA1:', ua1);
  console.log('UA2:', ua2);
  console.log('\nDifference in UAs: Chrome/120 vs Chrome/121');
  
  // Find where the keystrams differ
  console.log('\nPositions where keystrams differ:');
  const diffPositions = [];
  for (let i = 0; i < Math.min(ks1.length, ks2.length); i++) {
    if (ks1[i] !== ks2[i]) {
      diffPositions.push(i);
      if (diffPositions.length <= 20) {
        console.log(`  [${i}] ks1=${ks1[i].toString(16).padStart(2, '0')} ks2=${ks2[i].toString(16).padStart(2, '0')} diff=${(ks1[i] ^ ks2[i]).toString(16).padStart(2, '0')}`);
      }
    }
  }
  console.log(`Total differences: ${diffPositions.length}/${Math.min(ks1.length, ks2.length)}`);
  
  // Check if differences follow a pattern related to UA position
  // The UAs differ at position 89 (0 vs 1)
  const uaDiffPos = 89; // "Chrome/120" vs "Chrome/121"
  console.log(`\nUA differs at position ${uaDiffPos}`);
  
  // Check if keystream differences are related to UA position
  console.log('\nAnalyzing difference pattern...');
  
  // Try to find if there's a modular relationship
  for (const mod of [ua1.length, 64, 128, 256]) {
    const modDiffs = diffPositions.map(p => p % mod);
    const uniqueMods = [...new Set(modDiffs)];
    console.log(`  mod ${mod}: ${uniqueMods.length} unique positions`);
  }
  
  // Try to understand the cipher
  // It seems like a stream cipher where each byte of keystream depends on UA
  
  // Let's try to find if it's a simple XOR with UA repeated
  console.log('\n--- Testing simple XOR with UA ---');
  const testDecrypted = '{"sources":[{"file":"https://';
  const testEncrypted = Buffer.from(ks1.slice(0, testDecrypted.length).map((k, i) => k ^ testDecrypted.charCodeAt(i)));
  
  // XOR with UA
  let xorResult = '';
  for (let i = 0; i < testDecrypted.length; i++) {
    xorResult += String.fromCharCode(ks1[i] ^ ua1.charCodeAt(i % ua1.length));
  }
  console.log('XOR(keystream, UA):', xorResult.substring(0, 50));
  
  // Try to find the algorithm by looking at the relationship
  console.log('\n--- Analyzing keystream generation ---');
  
  // The keystream might be generated by: keystream[i] = f(UA, i)
  // Let's see if there's a pattern
  
  // Check if keystream[i] = UA[i % UA.length] XOR something
  const xorWithUA = ks1.map((k, i) => k ^ ua1.charCodeAt(i % ua1.length));
  console.log('keystream XOR UA (first 32):', Buffer.from(xorWithUA.slice(0, 32)).toString('hex'));
  
  // Check if the XOR result has a pattern
  const xorHistogram = new Array(256).fill(0);
  for (const byte of xorWithUA) {
    xorHistogram[byte]++;
  }
  const topBytes = xorHistogram.map((count, byte) => ({ byte, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 10);
  console.log('Most common bytes in (keystream XOR UA):', topBytes.map(b => `${b.byte.toString(16)}:${b.count}`).join(', '));
  
  // Try RC4 with UA as key, then XOR with something
  console.log('\n--- Testing RC4 variations ---');
  
  // Generate RC4 keystream with UA
  const rc4Ks = generateRC4Keystream(ua1, ks1.length);
  
  // XOR RC4 keystream with actual keystream
  const rc4Diff = ks1.map((k, i) => k ^ rc4Ks[i]);
  console.log('keystream XOR RC4(UA) (first 32):', Buffer.from(rc4Diff.slice(0, 32)).toString('hex'));
  
  // Check if RC4 diff is constant or has a pattern
  const rc4DiffHistogram = new Array(256).fill(0);
  for (const byte of rc4Diff) {
    rc4DiffHistogram[byte]++;
  }
  const topRc4Diff = rc4DiffHistogram.map((count, byte) => ({ byte, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 10);
  console.log('Most common bytes in (keystream XOR RC4(UA)):', topRc4Diff.map(b => `${b.byte.toString(16)}:${b.count}`).join(', '));
}

function generateRC4Keystream(key, length) {
  const S = new Array(256);
  for (let i = 0; i < 256; i++) S[i] = i;
  
  let j = 0;
  for (let i = 0; i < 256; i++) {
    j = (j + S[i] + key.charCodeAt(i % key.length)) % 256;
    [S[i], S[j]] = [S[j], S[i]];
  }
  
  const keystream = [];
  let i = 0;
  j = 0;
  for (let k = 0; k < length; k++) {
    i = (i + 1) % 256;
    j = (j + S[i]) % 256;
    [S[i], S[j]] = [S[j], S[i]];
    keystream.push(S[(S[i] + S[j]) % 256]);
  }
  return keystream;
}

main().catch(console.error);
