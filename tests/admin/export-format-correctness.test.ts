/**
 * Property-Based Test: Export Format Correctness
 * Feature: admin-panel-production-ready, Property 5: Export format correctness
 * 
 * Tests that for any export operation, the generated file should be in the 
 * correct format (CSV, JSON, PDF) with valid structure.
 * 
 * Validates: Requirements 9.1
 */

import { describe, test, expect } from 'bun:test';
import * as fc from 'fast-check';

// Export format types
type ExportFormat = 'csv' | 'json' | 'pdf';
type ExportType = 'analytics' | 'users' | 'content' | 'traffic' | 'system-health';

// Export metadata interface matching the API
interface ExportMetadata {
  exportId: string;
  exportType: string;
  generatedAt: number;
  generatedBy: string;
  dataSource: string;
  dateRange: {
    startDate: number;
    endDate: number;
  };
  recordCount: number;
  exportFormat: string;
  version: string;
  filters?: Record<string, any>;
  additionalInfo: {
    processingTimeMs: number;
    serverInstance: string;
    apiVersion: string;
    queryExecutionTime?: number;
  };
}

// Data record interface
interface DataRecord {
  [key: string]: string | number | boolean | null;
}

/**
 * Export formatter service that mirrors the API implementation
 */
class ExportFormatter {
  static formatAsCSV(data: DataRecord[], metadata: ExportMetadata): string {
    const lines = [
      '# Export Metadata',
      `# Export ID: ${metadata.exportId}`,
      `# Export Type: ${metadata.exportType}`,
      `# Generated At: ${new Date(metadata.generatedAt).toISOString()}`,
      `# Generated By: ${metadata.generatedBy}`,
      `# Data Source: ${metadata.dataSource}`,
      `# Date Range: ${new Date(metadata.dateRange.startDate).toISOString()} to ${new Date(metadata.dateRange.endDate).toISOString()}`,
      `# Record Count: ${metadata.recordCount}`,
      `# Export Format: ${metadata.exportFormat}`,
      `# Version: ${metadata.version}`,
      `# Processing Time: ${metadata.additionalInfo.processingTimeMs}ms`,
      ''
    ];

    if (data.length > 0) {
      const headers = Object.keys(data[0]);
      lines.push(headers.join(','));
      
      for (const record of data) {
        const values = headers.map(header => {
          const value = record[header];
          if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
            return `"${value.replace(/"/g, '""')}"`;
          }
          return String(value ?? '');
        });
        lines.push(values.join(','));
      }
    } else {
      lines.push('No data available for the specified criteria');
    }

    return lines.join('\n');
  }

  static formatAsJSON(data: DataRecord[], metadata: ExportMetadata): string {
    return JSON.stringify({ data, metadata }, null, 2);
  }

  static formatAsPDF(data: DataRecord[], metadata: ExportMetadata): string {
    const content = [
      '%PDF-1.4',
      `Analytics Export Report`,
      '',
      'Export Metadata:',
      `- Export ID: ${metadata.exportId}`,
      `- Export Type: ${metadata.exportType}`,
      `- Generated At: ${new Date(metadata.generatedAt).toISOString()}`,
      `- Generated By: ${metadata.generatedBy}`,
      `- Data Source: ${metadata.dataSource}`,
      `- Date Range: ${new Date(metadata.dateRange.startDate).toISOString()} to ${new Date(metadata.dateRange.endDate).toISOString()}`,
      `- Record Count: ${metadata.recordCount}`,
      `- Export Format: ${metadata.exportFormat}`,
      `- Version: ${metadata.version}`,
      `- Processing Time: ${metadata.additionalInfo.processingTimeMs}ms`,
      '',
      'Data Summary:',
    ];

    if (data.length > 0) {
      content.push(`Total Records: ${data.length}`);
      content.push('');
      content.push('Sample Data:');
      
      const sampleData = data.slice(0, 10);
      for (const record of sampleData) {
        const recordStr = Object.entries(record)
          .map(([key, value]) => `${key}: ${value}`)
          .join(', ');
        content.push(`- ${recordStr}`);
      }
      
      if (data.length > 10) {
        content.push(`... and ${data.length - 10} more records`);
      }
    } else {
      content.push('No data available for the specified criteria');
    }

    return content.join('\n');
  }

  static format(data: DataRecord[], metadata: ExportMetadata, format: ExportFormat): string {
    switch (format) {
      case 'csv':
        return this.formatAsCSV(data, metadata);
      case 'json':
        return this.formatAsJSON(data, metadata);
      case 'pdf':
        return this.formatAsPDF(data, metadata);
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }
}

// Generators
const exportFormatArbitrary = fc.constantFrom<ExportFormat>('csv', 'json', 'pdf');
const exportTypeArbitrary = fc.constantFrom<ExportType>('analytics', 'users', 'content', 'traffic', 'system-health');

const dataRecordArbitrary = fc.record({
  id: fc.uuid(),
  name: fc.string({ minLength: 1, maxLength: 50 }).filter(s => !s.includes('\n')),
  value: fc.integer({ min: 0, max: 100000 }),
  timestamp: fc.integer({ min: 1640995200000, max: Date.now() })
});

const dataRecordsArbitrary = fc.array(dataRecordArbitrary, { minLength: 0, maxLength: 50 });

const metadataArbitrary = fc.record({
  exportId: fc.string({ minLength: 10, maxLength: 30 }).map(s => `export_${Date.now()}_${s.replace(/[^a-z0-9]/gi, '')}`),
  exportType: exportTypeArbitrary,
  generatedAt: fc.integer({ min: 1640995200000, max: Date.now() }),
  generatedBy: fc.uuid(),
  dataSource: fc.constant('unified-analytics-api'),
  dateRange: fc.tuple(
    fc.integer({ min: 1640995200000, max: Date.now() - 86400000 }),
    fc.integer({ min: 1640995200000, max: Date.now() })
  ).map(([start, end]) => ({
    startDate: Math.min(start, end),
    endDate: Math.max(start, end)
  })),
  recordCount: fc.integer({ min: 0, max: 10000 }),
  exportFormat: exportFormatArbitrary,
  version: fc.constant('1.0.0'),
  additionalInfo: fc.record({
    processingTimeMs: fc.integer({ min: 0, max: 5000 }),
    serverInstance: fc.constant('analytics-server-01'),
    apiVersion: fc.constant('v2.1.0'),
    queryExecutionTime: fc.integer({ min: 0, max: 1000 })
  })
});

describe('Export Format Correctness Property Tests', () => {
  test('Property 5: Export format correctness - CSV format is valid', () => {
    fc.assert(
      fc.property(
        dataRecordsArbitrary,
        metadataArbitrary,
        (data, metadata) => {
          const csvOutput = ExportFormatter.format(data, { ...metadata, recordCount: data.length }, 'csv');
          
          // CSV should start with metadata comments
          expect(csvOutput).toContain('# Export Metadata');
          expect(csvOutput).toContain('# Export ID:');
          expect(csvOutput).toContain('# Export Type:');
          expect(csvOutput).toContain('# Generated At:');
          expect(csvOutput).toContain('# Data Source:');
          expect(csvOutput).toContain('# Date Range:');
          expect(csvOutput).toContain('# Record Count:');
          expect(csvOutput).toContain('# Version:');
          
          // If data exists, should have headers
          if (data.length > 0) {
            const lines = csvOutput.split('\n').filter(l => !l.startsWith('#') && l.trim());
            expect(lines.length).toBeGreaterThan(0);
            // First non-comment line should be headers
            expect(lines[0]).toContain('id');
          }
          
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Property 5: Export format correctness - JSON format is valid and parseable', () => {
    fc.assert(
      fc.property(
        dataRecordsArbitrary,
        metadataArbitrary,
        (data, metadata) => {
          const jsonOutput = ExportFormatter.format(data, { ...metadata, recordCount: data.length }, 'json');
          
          // JSON should be parseable
          const parsed = JSON.parse(jsonOutput);
          
          // Should have data and metadata
          expect(parsed.data).toBeDefined();
          expect(parsed.metadata).toBeDefined();
          expect(Array.isArray(parsed.data)).toBe(true);
          expect(parsed.data.length).toBe(data.length);
          
          // Metadata should have required fields
          expect(parsed.metadata.exportId).toBeDefined();
          expect(parsed.metadata.exportType).toBeDefined();
          expect(parsed.metadata.generatedAt).toBeGreaterThan(0);
          expect(parsed.metadata.dataSource).toBe('unified-analytics-api');
          expect(parsed.metadata.dateRange).toBeDefined();
          expect(parsed.metadata.recordCount).toBe(data.length);
          
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Property 5: Export format correctness - PDF format has required structure', () => {
    fc.assert(
      fc.property(
        dataRecordsArbitrary,
        metadataArbitrary,
        (data, metadata) => {
          const pdfOutput = ExportFormatter.format(data, { ...metadata, recordCount: data.length }, 'pdf');
          
          // PDF should have header
          expect(pdfOutput).toContain('%PDF-1.4');
          expect(pdfOutput).toContain('Analytics Export Report');
          
          // Should have metadata section
          expect(pdfOutput).toContain('Export Metadata:');
          expect(pdfOutput).toContain('Export ID:');
          expect(pdfOutput).toContain('Export Type:');
          expect(pdfOutput).toContain('Generated At:');
          expect(pdfOutput).toContain('Data Source:');
          expect(pdfOutput).toContain('Date Range:');
          expect(pdfOutput).toContain('Record Count:');
          
          // Should have data summary
          expect(pdfOutput).toContain('Data Summary:');
          
          if (data.length > 0) {
            expect(pdfOutput).toContain(`Total Records: ${data.length}`);
            expect(pdfOutput).toContain('Sample Data:');
          }
          
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Property 5: Export format correctness - All formats contain same core data', () => {
    fc.assert(
      fc.property(
        dataRecordsArbitrary,
        metadataArbitrary,
        (data, metadata) => {
          const updatedMetadata = { ...metadata, recordCount: data.length };
          
          const csvOutput = ExportFormatter.format(data, updatedMetadata, 'csv');
          const jsonOutput = ExportFormatter.format(data, updatedMetadata, 'json');
          const pdfOutput = ExportFormatter.format(data, updatedMetadata, 'pdf');
          
          // All formats should contain the record count
          expect(csvOutput).toContain(data.length.toString());
          expect(jsonOutput).toContain(data.length.toString());
          expect(pdfOutput).toContain(data.length.toString());
          
          // All formats should contain the export type
          expect(csvOutput).toContain(metadata.exportType);
          expect(jsonOutput).toContain(metadata.exportType);
          expect(pdfOutput).toContain(metadata.exportType);
          
          // All formats should contain the data source
          expect(csvOutput).toContain('unified-analytics-api');
          expect(jsonOutput).toContain('unified-analytics-api');
          expect(pdfOutput).toContain('unified-analytics-api');
          
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Property 5: Export format correctness - Invalid format throws error', () => {
    fc.assert(
      fc.property(
        dataRecordsArbitrary,
        metadataArbitrary,
        fc.string().filter(s => !['csv', 'json', 'pdf'].includes(s.toLowerCase())),
        (data, metadata, invalidFormat) => {
          expect(() => {
            ExportFormatter.format(data, metadata, invalidFormat as ExportFormat);
          }).toThrow();
          
          return true;
        }
      ),
      { numRuns: 50 }
    );
  });
});
