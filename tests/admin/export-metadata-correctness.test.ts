/**
 * Property-Based Test: Export Metadata Inclusion
 * Feature: admin-panel-production-ready, Property 7: Export metadata inclusion
 * 
 * Tests that for any data export, the output should include timestamp, 
 * date range, and data source metadata.
 * 
 * Validates: Requirements 9.4
 */

import { describe, test, expect } from 'bun:test';
import * as fc from 'fast-check';

// Export format types
type ExportFormat = 'csv' | 'json' | 'pdf';
type ExportType = 'analytics' | 'users' | 'content' | 'traffic' | 'system-health';

// Export metadata interface matching the API
interface ExportMetadata {
  exportId: string;
  exportType: string;
  generatedAt: number;
  generatedBy: string;
  dataSource: string;
  dateRange: {
    startDate: number;
    endDate: number;
  };
  recordCount: number;
  exportFormat: string;
  version: string;
  filters?: Record<string, any>;
  additionalInfo: {
    processingTimeMs: number;
    serverInstance: string;
    apiVersion: string;
    queryExecutionTime?: number;
  };
}

// Export request interface
interface ExportRequest {
  exportType: ExportType;
  format: ExportFormat;
  dateRange: {
    startDate: number;
    endDate: number;
  };
  userId: string;
  filters?: Record<string, any>;
  includeMetadata: boolean;
}

// Data record interface
interface DataRecord {
  [key: string]: string | number | boolean | null;
}

/**
 * Export metadata service that mirrors the API implementation
 */
class ExportMetadataService {
  private static readonly VERSION = '1.0.0';
  private static readonly DATA_SOURCE = 'unified-analytics-api';
  private static readonly API_VERSION = 'v2.1.0';
  private static readonly SERVER_INSTANCE = 'analytics-server-01';

  static generateMetadata(request: ExportRequest, recordCount: number): ExportMetadata {
    const now = Date.now();
    
    return {
      exportId: `export_${now}_${Math.random().toString(36).substr(2, 9)}`,
      exportType: request.exportType,
      generatedAt: now,
      generatedBy: request.userId,
      dataSource: this.DATA_SOURCE,
      dateRange: request.dateRange,
      recordCount,
      exportFormat: request.format,
      version: this.VERSION,
      filters: request.filters,
      additionalInfo: {
        processingTimeMs: Math.floor(Math.random() * 1000),
        serverInstance: this.SERVER_INSTANCE,
        apiVersion: this.API_VERSION,
        queryExecutionTime: Math.floor(Math.random() * 500)
      }
    };
  }

  static formatWithMetadata(data: DataRecord[], metadata: ExportMetadata, format: ExportFormat): string {
    switch (format) {
      case 'json':
        return JSON.stringify({ data, metadata }, null, 2);
        
      case 'csv':
        const csvLines = [
          '# Export Metadata',
          `# Export ID: ${metadata.exportId}`,
          `# Export Type: ${metadata.exportType}`,
          `# Generated At: ${new Date(metadata.generatedAt).toISOString()}`,
          `# Generated By: ${metadata.generatedBy}`,
          `# Data Source: ${metadata.dataSource}`,
          `# Date Range: ${new Date(metadata.dateRange.startDate).toISOString()} to ${new Date(metadata.dateRange.endDate).toISOString()}`,
          `# Record Count: ${metadata.recordCount}`,
          `# Export Format: ${metadata.exportFormat}`,
          `# Version: ${metadata.version}`,
          `# Processing Time: ${metadata.additionalInfo.processingTimeMs}ms`,
          ''
        ];
        
        if (data.length > 0) {
          const headers = Object.keys(data[0]);
          csvLines.push(headers.join(','));
          for (const record of data) {
            csvLines.push(headers.map(h => String(record[h] ?? '')).join(','));
          }
        }
        
        return csvLines.join('\n');
        
      case 'pdf':
        return `%PDF-1.4
Analytics Export Report

Export Metadata:
- Export ID: ${metadata.exportId}
- Export Type: ${metadata.exportType}
- Generated At: ${new Date(metadata.generatedAt).toISOString()}
- Generated By: ${metadata.generatedBy}
- Data Source: ${metadata.dataSource}
- Date Range: ${new Date(metadata.dateRange.startDate).toISOString()} to ${new Date(metadata.dateRange.endDate).toISOString()}
- Record Count: ${metadata.recordCount}
- Export Format: ${metadata.exportFormat}
- Version: ${metadata.version}
- Processing Time: ${metadata.additionalInfo.processingTimeMs}ms

Data Summary:
Total Records: ${data.length}
`;
        
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }
}

// Generators
const exportFormatArbitrary = fc.constantFrom<ExportFormat>('csv', 'json', 'pdf');
const exportTypeArbitrary = fc.constantFrom<ExportType>('analytics', 'users', 'content', 'traffic', 'system-health');

const exportRequestArbitrary = fc.record({
  exportType: exportTypeArbitrary,
  format: exportFormatArbitrary,
  dateRange: fc.tuple(
    fc.integer({ min: 1640995200000, max: Date.now() - 86400000 }),
    fc.integer({ min: 1640995200000, max: Date.now() })
  ).map(([start, end]) => ({
    startDate: Math.min(start, end),
    endDate: Math.max(start, end)
  })),
  userId: fc.uuid(),
  filters: fc.option(fc.record({
    country: fc.option(fc.string({ minLength: 2, maxLength: 2 })),
    deviceType: fc.option(fc.constantFrom('desktop', 'mobile', 'tablet'))
  })),
  includeMetadata: fc.constant(true)
});

const dataRecordArbitrary = fc.record({
  id: fc.uuid(),
  name: fc.string({ minLength: 1, maxLength: 30 }).filter(s => !s.includes('\n') && !s.includes(',')),
  value: fc.integer({ min: 0, max: 10000 })
});

const dataRecordsArbitrary = fc.array(dataRecordArbitrary, { minLength: 0, maxLength: 50 });

describe('Export Metadata Inclusion Property Tests', () => {
  test('Property 7: Export metadata inclusion - All required metadata fields present', () => {
    fc.assert(
      fc.property(
        exportRequestArbitrary,
        dataRecordsArbitrary,
        (request, data) => {
          const metadata = ExportMetadataService.generateMetadata(request, data.length);
          
          // Verify all required metadata fields are present
          expect(metadata.exportId).toBeDefined();
          expect(typeof metadata.exportId).toBe('string');
          expect(metadata.exportId.length).toBeGreaterThan(0);
          
          expect(metadata.exportType).toBe(request.exportType);
          expect(metadata.generatedAt).toBeGreaterThan(0);
          expect(metadata.generatedBy).toBe(request.userId);
          expect(metadata.dataSource).toBe('unified-analytics-api');
          
          expect(metadata.dateRange).toEqual(request.dateRange);
          expect(metadata.recordCount).toBe(data.length);
          expect(metadata.exportFormat).toBe(request.format);
          expect(metadata.version).toBe('1.0.0');
          
          // Additional info should be present
          expect(metadata.additionalInfo).toBeDefined();
          expect(metadata.additionalInfo.processingTimeMs).toBeGreaterThanOrEqual(0);
          expect(metadata.additionalInfo.serverInstance).toBe('analytics-server-01');
          expect(metadata.additionalInfo.apiVersion).toBe('v2.1.0');
          
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Property 7: Export metadata inclusion - Timestamp is accurate', () => {
    fc.assert(
      fc.property(
        exportRequestArbitrary,
        dataRecordsArbitrary,
        (request, data) => {
          const beforeGeneration = Date.now();
          const metadata = ExportMetadataService.generateMetadata(request, data.length);
          const afterGeneration = Date.now();
          
          // Generated timestamp should be within reasonable bounds
          expect(metadata.generatedAt).toBeGreaterThanOrEqual(beforeGeneration - 100);
          expect(metadata.generatedAt).toBeLessThanOrEqual(afterGeneration + 100);
          
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Property 7: Export metadata inclusion - Date range preserved in metadata', () => {
    fc.assert(
      fc.property(
        exportRequestArbitrary,
        dataRecordsArbitrary,
        (request, data) => {
          const metadata = ExportMetadataService.generateMetadata(request, data.length);
          
          // Date range should be preserved exactly
          expect(metadata.dateRange.startDate).toBe(request.dateRange.startDate);
          expect(metadata.dateRange.endDate).toBe(request.dateRange.endDate);
          
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Property 7: Export metadata inclusion - Data source always included', () => {
    fc.assert(
      fc.property(
        exportRequestArbitrary,
        dataRecordsArbitrary,
        (request, data) => {
          const metadata = ExportMetadataService.generateMetadata(request, data.length);
          
          // Data source should always be present and consistent
          expect(metadata.dataSource).toBe('unified-analytics-api');
          expect(metadata.dataSource.length).toBeGreaterThan(0);
          
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Property 7: Export metadata inclusion - Metadata in formatted output (JSON)', () => {
    fc.assert(
      fc.property(
        exportRequestArbitrary,
        dataRecordsArbitrary,
        (request, data) => {
          const metadata = ExportMetadataService.generateMetadata(request, data.length);
          const output = ExportMetadataService.formatWithMetadata(data, metadata, 'json');
          
          // JSON should be parseable and contain metadata
          const parsed = JSON.parse(output);
          expect(parsed.metadata).toBeDefined();
          expect(parsed.metadata.exportId).toBe(metadata.exportId);
          expect(parsed.metadata.generatedAt).toBe(metadata.generatedAt);
          expect(parsed.metadata.dataSource).toBe('unified-analytics-api');
          expect(parsed.metadata.dateRange).toEqual(metadata.dateRange);
          expect(parsed.metadata.recordCount).toBe(data.length);
          
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Property 7: Export metadata inclusion - Metadata in formatted output (CSV)', () => {
    fc.assert(
      fc.property(
        exportRequestArbitrary,
        dataRecordsArbitrary,
        (request, data) => {
          const metadata = ExportMetadataService.generateMetadata(request, data.length);
          const output = ExportMetadataService.formatWithMetadata(data, metadata, 'csv');
          
          // CSV should contain metadata comments
          expect(output).toContain('# Export Metadata');
          expect(output).toContain(`# Export ID: ${metadata.exportId}`);
          expect(output).toContain('# Generated At:');
          expect(output).toContain(`# Generated By: ${metadata.generatedBy}`);
          expect(output).toContain('# Data Source: unified-analytics-api');
          expect(output).toContain('# Date Range:');
          expect(output).toContain(`# Record Count: ${data.length}`);
          expect(output).toContain(`# Version: ${metadata.version}`);
          
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Property 7: Export metadata inclusion - Metadata in formatted output (PDF)', () => {
    fc.assert(
      fc.property(
        exportRequestArbitrary,
        dataRecordsArbitrary,
        (request, data) => {
          const metadata = ExportMetadataService.generateMetadata(request, data.length);
          const output = ExportMetadataService.formatWithMetadata(data, metadata, 'pdf');
          
          // PDF should contain metadata section
          expect(output).toContain('%PDF-1.4');
          expect(output).toContain('Export Metadata:');
          expect(output).toContain(`Export ID: ${metadata.exportId}`);
          expect(output).toContain('Generated At:');
          expect(output).toContain(`Generated By: ${metadata.generatedBy}`);
          expect(output).toContain('Data Source: unified-analytics-api');
          expect(output).toContain('Date Range:');
          expect(output).toContain(`Record Count: ${data.length}`);
          
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Property 7: Export metadata inclusion - Unique export IDs', () => {
    fc.assert(
      fc.property(
        exportRequestArbitrary,
        dataRecordsArbitrary,
        (request, data) => {
          // Generate multiple exports and verify unique IDs
          const exports = [];
          for (let i = 0; i < 10; i++) {
            exports.push(ExportMetadataService.generateMetadata(request, data.length));
          }
          
          const exportIds = exports.map(e => e.exportId);
          const uniqueIds = new Set(exportIds);
          
          // All export IDs should be unique
          expect(uniqueIds.size).toBe(exportIds.length);
          
          // Each ID should follow expected format
          for (const id of exportIds) {
            expect(id).toMatch(/^export_\d+_[a-z0-9]+$/);
          }
          
          return true;
        }
      ),
      { numRuns: 50 }
    );
  });
});
