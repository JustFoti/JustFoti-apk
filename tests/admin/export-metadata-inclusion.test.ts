/**
 * Property-Based Test: Export Metadata Inclusion
 * Feature: admin-panel-unified-refactor, Property 37: Export metadata inclusion
 * 
 * Tests that for any data export, the output includes relevant metadata such as 
 * generation timestamp, date range, and data source information.
 * 
 * Validates: Requirements 8.4
 */

import { describe, test, expect } from 'bun:test';
import * as fc from 'fast-check';

// Export metadata interface
interface ExportMetadata {
  exportId: string;
  exportType: string;
  generatedAt: number;
  generatedBy: string;
  dataSource: string;
  dateRange: {
    startDate: number;
    endDate: number;
  };
  recordCount: number;
  exportFormat: string;
  version: string;
  filters?: Record<string, any>;
  additionalInfo?: Record<string, any>;
}

// Export request interface
interface ExportRequest {
  exportType: string;
  format: string;
  dateRange: {
    startDate: number;
    endDate: number;
  };
  userId: string;
  filters?: Record<string, any>;
  includeMetadata: boolean;
}

// Mock export service
class ExportService {
  private static readonly VERSION = '1.0.0';
  private static readonly DATA_SOURCE = 'unified-analytics-api';

  static generateExport(request: ExportRequest, data: any[]): {
    data: any[];
    metadata: ExportMetadata;
  } {
    const now = Date.now();
    
    const metadata: ExportMetadata = {
      exportId: `export_${now}_${Math.random().toString(36).substr(2, 9)}`,
      exportType: request.exportType,
      generatedAt: now,
      generatedBy: request.userId,
      dataSource: this.DATA_SOURCE,
      dateRange: request.dateRange,
      recordCount: data.length,
      exportFormat: request.format,
      version: this.VERSION,
      filters: request.filters,
      additionalInfo: {
        processingTimeMs: Math.floor(Math.random() * 1000),
        serverInstance: 'analytics-server-01',
        apiVersion: 'v2.1.0'
      }
    };

    return {
      data,
      metadata
    };
  }

  static exportToFormat(request: ExportRequest, data: any[]): string {
    const exportResult = this.generateExport(request, data);
    
    switch (request.format.toLowerCase()) {
      case 'json':
        return JSON.stringify(exportResult, null, 2);
        
      case 'csv':
        const csvLines = [
          '# Export Metadata',
          `# Export ID: ${exportResult.metadata.exportId}`,
          `# Export Type: ${exportResult.metadata.exportType}`,
          `# Generated At: ${new Date(exportResult.metadata.generatedAt).toISOString()}`,
          `# Generated By: ${exportResult.metadata.generatedBy}`,
          `# Data Source: ${exportResult.metadata.dataSource}`,
          `# Date Range: ${new Date(exportResult.metadata.dateRange.startDate).toISOString()} to ${new Date(exportResult.metadata.dateRange.endDate).toISOString()}`,
          `# Record Count: ${exportResult.metadata.recordCount}`,
          `# Export Format: ${exportResult.metadata.exportFormat}`,
          `# Version: ${exportResult.metadata.version}`,
          '',
          'Data,Value',
          ...data.map(item => `${item.name || 'unknown'},${item.value || 0}`)
        ];
        return csvLines.join('\n');
        
      case 'pdf':
        return `%PDF-1.4
Export Metadata:
- Export ID: ${exportResult.metadata.exportId}
- Export Type: ${exportResult.metadata.exportType}
- Generated At: ${new Date(exportResult.metadata.generatedAt).toISOString()}
- Generated By: ${exportResult.metadata.generatedBy}
- Data Source: ${exportResult.metadata.dataSource}
- Date Range: ${new Date(exportResult.metadata.dateRange.startDate).toISOString()} to ${new Date(exportResult.metadata.dateRange.endDate).toISOString()}
- Record Count: ${exportResult.metadata.recordCount}
- Export Format: ${exportResult.metadata.exportFormat}
- Version: ${exportResult.metadata.version}

Data:
${data.map(item => `${item.name || 'unknown'}: ${item.value || 0}`).join('\n')}
`;
        
      default:
        throw new Error(`Unsupported format: ${request.format}`);
    }
  }
}

// Property-based test generators
const exportRequestArbitrary = fc.record({
  exportType: fc.constantFrom('analytics', 'users', 'content', 'traffic', 'system-health'),
  format: fc.constantFrom('json', 'csv', 'pdf'),
  dateRange: fc.tuple(
    fc.integer({ min: 1640995200000, max: Date.now() - 86400000 }),
    fc.integer({ min: 1640995200000, max: Date.now() })
  ).map(([start, end]) => ({
    startDate: Math.min(start, end),
    endDate: Math.max(start, end)
  })),
  userId: fc.uuid(),
  filters: fc.option(fc.record({
    country: fc.option(fc.string({ minLength: 2, maxLength: 2 })),
    deviceType: fc.option(fc.constantFrom('desktop', 'mobile', 'tablet')),
    contentType: fc.option(fc.constantFrom('movie', 'tv', 'live'))
  })),
  includeMetadata: fc.constant(true)
});

const dataArrayArbitrary = fc.array(
  fc.record({
    name: fc.string({ minLength: 1, maxLength: 50 }),
    value: fc.integer({ min: 0, max: 100000 }),
    timestamp: fc.integer({ min: 1640995200000, max: Date.now() })
  }),
  { minLength: 0, maxLength: 100 }
);

describe('Export Metadata Inclusion Property Tests', () => {
  test('Property 37: Export metadata inclusion - All required metadata fields present', () => {
    fc.assert(
      fc.property(
        exportRequestArbitrary,
        dataArrayArbitrary,
        (request, data) => {
          const result = ExportService.generateExport(request, data);
          
          // Verify all required metadata fields are present
          expect(result.metadata.exportId).toBeDefined();
          expect(typeof result.metadata.exportId).toBe('string');
          expect(result.metadata.exportId.length).toBeGreaterThan(0);
          
          expect(result.metadata.exportType).toBe(request.exportType);
          expect(result.metadata.generatedAt).toBeGreaterThan(0);
          expect(result.metadata.generatedBy).toBe(request.userId);
          expect(result.metadata.dataSource).toBe('unified-analytics-api');
          
          expect(result.metadata.dateRange).toEqual(request.dateRange);
          expect(result.metadata.recordCount).toBe(data.length);
          expect(result.metadata.exportFormat).toBe(request.format);
          expect(result.metadata.version).toBeDefined();
          
          // Optional fields should be handled correctly
          if (request.filters) {
            expect(result.metadata.filters).toEqual(request.filters);
          }
          
          expect(result.metadata.additionalInfo).toBeDefined();
          expect(result.metadata.additionalInfo?.processingTimeMs).toBeGreaterThanOrEqual(0);
          expect(result.metadata.additionalInfo?.serverInstance).toBeDefined();
          expect(result.metadata.additionalInfo?.apiVersion).toBeDefined();
          
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Property 37: Export metadata inclusion - Metadata in formatted output', () => {
    fc.assert(
      fc.property(
        exportRequestArbitrary,
        dataArrayArbitrary,
        (request, data) => {
          const formattedOutput = ExportService.exportToFormat(request, data);
          
          // Verify metadata is included in the formatted output
          expect(formattedOutput).toContain(request.exportType);
          expect(formattedOutput).toContain(request.userId);
          expect(formattedOutput).toContain('unified-analytics-api');
          expect(formattedOutput).toContain(data.length.toString());
          expect(formattedOutput).toContain(request.format);
          
          // Format-specific metadata checks
          switch (request.format.toLowerCase()) {
            case 'json':
              const parsed = JSON.parse(formattedOutput);
              expect(parsed.metadata).toBeDefined();
              expect(parsed.metadata.exportId).toBeDefined();
              expect(parsed.metadata.generatedAt).toBeGreaterThan(0);
              expect(parsed.data).toEqual(data);
              break;
              
            case 'csv':
              expect(formattedOutput).toContain('# Export Metadata');
              expect(formattedOutput).toContain('# Export ID:');
              expect(formattedOutput).toContain('# Generated At:');
              expect(formattedOutput).toContain('# Data Source:');
              expect(formattedOutput).toContain('# Record Count:');
              break;
              
            case 'pdf':
              expect(formattedOutput).toContain('%PDF-1.4');
              expect(formattedOutput).toContain('Export Metadata:');
              expect(formattedOutput).toContain('Export ID:');
              expect(formattedOutput).toContain('Generated At:');
              expect(formattedOutput).toContain('Data Source:');
              expect(formattedOutput).toContain('Record Count:');
              break;
          }
          
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Property 37: Export metadata inclusion - Timestamp accuracy', () => {
    fc.assert(
      fc.property(
        exportRequestArbitrary,
        dataArrayArbitrary,
        (request, data) => {
          const beforeExport = Date.now();
          const result = ExportService.generateExport(request, data);
          const afterExport = Date.now();
          
          // Generated timestamp should be within reasonable bounds
          expect(result.metadata.generatedAt).toBeGreaterThanOrEqual(beforeExport - 1000);
          expect(result.metadata.generatedAt).toBeLessThanOrEqual(afterExport + 1000);
          
          // Date range should be preserved exactly
          expect(result.metadata.dateRange.startDate).toBe(request.dateRange.startDate);
          expect(result.metadata.dateRange.endDate).toBe(request.dateRange.endDate);
          
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Property 37: Export metadata inclusion - Unique export IDs', () => {
    fc.assert(
      fc.property(
        exportRequestArbitrary,
        dataArrayArbitrary,
        (request, data) => {
          // Generate multiple exports and verify unique IDs
          const exports = [];
          for (let i = 0; i < 10; i++) {
            exports.push(ExportService.generateExport(request, data));
          }
          
          const exportIds = exports.map(e => e.metadata.exportId);
          const uniqueIds = new Set(exportIds);
          
          // All export IDs should be unique
          expect(uniqueIds.size).toBe(exportIds.length);
          
          // Each ID should follow expected format
          for (const id of exportIds) {
            expect(id).toMatch(/^export_\d+_[a-z0-9]+$/);
          }
          
          return true;
        }
      ),
      { numRuns: 50 }
    );
  });

  test('Property 37: Export metadata inclusion - Record count accuracy', () => {
    fc.assert(
      fc.property(
        exportRequestArbitrary,
        dataArrayArbitrary,
        (request, data) => {
          const result = ExportService.generateExport(request, data);
          
          // Record count in metadata should match actual data length
          expect(result.metadata.recordCount).toBe(data.length);
          expect(result.data.length).toBe(data.length);
          
          // Data should be preserved unchanged
          expect(result.data).toEqual(data);
          
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Property 37: Export metadata inclusion - Filter preservation', () => {
    fc.assert(
      fc.property(
        exportRequestArbitrary,
        dataArrayArbitrary,
        (request, data) => {
          const result = ExportService.generateExport(request, data);
          
          // Filters should be preserved in metadata
          if (request.filters) {
            expect(result.metadata.filters).toEqual(request.filters);
          } else {
            // Accept both null and undefined for missing filters
            expect(result.metadata.filters == null).toBe(true);
          }
          
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Property 37: Export metadata inclusion - Version and source consistency', () => {
    fc.assert(
      fc.property(
        exportRequestArbitrary,
        dataArrayArbitrary,
        (request, data) => {
          const result = ExportService.generateExport(request, data);
          
          // Version and data source should be consistent across all exports
          expect(result.metadata.version).toBe('1.0.0');
          expect(result.metadata.dataSource).toBe('unified-analytics-api');
          
          // Additional info should always be present
          expect(result.metadata.additionalInfo).toBeDefined();
          expect(result.metadata.additionalInfo?.serverInstance).toBe('analytics-server-01');
          expect(result.metadata.additionalInfo?.apiVersion).toBe('v2.1.0');
          expect(typeof result.metadata.additionalInfo?.processingTimeMs).toBe('number');
          
          return true;
        }
      ),
      { numRuns: 100 }
    );
  });
});